{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/","result":{"data":{"markdownRemark":{"html":"<hr>\n<h1>UNION-FIND</h1>\n<p>최소 선형트리 알고리즘의 서브 루틴</p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UF(int N)</td>\n<td>union-find data (0 ~ N-1)</td>\n</tr>\n<tr>\n<td>union(p, q)</td>\n<td>add connection p, q</td>\n</tr>\n<tr>\n<td>connected(p, q)</td>\n<td>IsUnioned?</td>\n</tr>\n</tbody>\n</table>\n<h2>Quick Find (Eager approach)</h2>\n<ol>\n<li>Initialize<br>\n<code>id[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code><br>\n<code>ary[N]</code>으로 index == value<br>\nN번의 init </li>\n<li>Find<br>\n<code>return id[p] == id[q]</code><br>\n1번의 비용</li>\n<li>\n<p>Union<br>\n<code>id[] = [0, 1, 2, 3, 4]</code> - <code>union(1, 2)</code> -> <code>id[] = [0, 1, 1, 3, 4]</code><br>\n<code>p</code>, <code>q</code> 중 무엇으로 바꿀지 내부적으로 결정해야함<br>\n<code>id[p]</code>의 <code>index</code>를 찾아서 해당 값으로 수정<br>\nN<sup>2</sup>의 시간이 필요</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">for(let i=0;i&lt;id.length;i++)\n  if(id[i] == id[q]) id[i] = pid</code>\n        </deckgo-highlight-code>\n</li>\n</ol>\n<h2>Quick union (Lazy approach)</h2>\n<p>Quick find의 대안. <code>tree 구조</code>로 구성된 <code>forest</code></p>\n<ol>\n<li>Initialize<br>\n<code>id[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></li>\n<li>\n<p>Find<br>\n<code>Root</code> of <code>i</code> : <code>id[id[id[...id[i]...]]]</code><br>\n<code>id[i]</code>는 <code>i</code>의 <code>parent</code>. <code>parent</code>의 마지막 <code>parent</code>가 <code>root</code>  </p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">while(i != id[i]){\n  i = id[i]\n}</code>\n        </deckgo-highlight-code>\n<p><code>Long skinny tree</code>가 될수록 비용이 커짐</p>\n</li>\n<li>Union<br>\n<code>id[] = [0, 1, 9, 4, 9, 6, 6, 7, 8, 9]</code> -> <code>union(3, 5)</code><br>\n<code>p</code>의 <code>root</code> = <code>id[3] = id[4] = id[9] = 9</code><br>\n<code>q</code>의 <code>root</code> = <code>id[5] = id[6] = 6</code><br>\n=> <code>p</code>의 <code>root</code>인 <code>id[9]</code>의 값을 <code>6</code>으로 바꿔준다<br>\n최대 <code>N</code>번의 접근</li>\n</ol>\n<h2>향상된 quick union</h2>\n<p>동적 연결성(Dynamic connectivity) 문제를 해결하기 위함</p>\n<h3>가중치 (weighting)</h3>\n<p><code>union</code> 시 큰 트리를 작은 트리 아래에 넣지않음<br>\n<code>tree</code>의 <code>size</code>를 계속 트래킹 (<code>weighting</code>을 위한 추가 <code>ary</code> 사용)</p>\n<p><code>id[] = [0, 9, 6, 5, 4, 2, 6, 1, 0, 5]</code> -> <code>union(3, 8)</code><br>\n<code>id[3] = id[5] = id[2] = id[6]</code>, <code>id[8] = id[0]</code><br>\n이 때 <code>8</code>의 <code>tree</code>가 작기 때문에 <code>3</code>의 <code>root</code>를 따름\n=> 평균 거리가 짧아짐</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">  i = root(p)\n  j = root(q)\n  if(sz[i] &lt; sz[j])\n    id[i] = j; sz[j] += sz[i]\n  else\n    id[j] = i; sz[i] += sz[j]</code>\n        </deckgo-highlight-code>\n<p>node x의 최대 깊이가 클수록 트리는 최소 2배의 노드를 가짐</p>\n<ul>\n<li>x가 속한 tree 크기가 최대 log<sub>2</sub>N배만큼 커짐</li>\n<li>1 ~ log<sub>2</sub>N번 = 2배 = N\nunion = log<sub>2</sub>N</li>\n<li>N이 100만 ~ 10억일 때 20~30의 비용</li>\n</ul>\n<h3>경로 압축 (path compress)</h3>\n<p>node p의 <code>root</code>를 찾으려면 모든 단계의 노드를 찾아야 함<br>\n=> 모든 경로의 노드가 <code>root</code>를 가리키게 만듬 (flatten tree)<br>\n간단히 <code>root</code>를 찾을 때 <code>id[i] = id[id[i]]</code>로 grand parent를 찾을 수 있음</p>\n<h3>가중치와 경로 압축을 합친 QU</h3>\n<p>node n을 M번 union, find해도 c(N+M log<sup>*</sup> N) 시간 소요  </p>\n<ul>\n<li><em>log<sup>*</sup> N : N을 1로 바꾸기 위해 logN을 취해야하는 횟수</em></li>\n</ul>\n<h2>Percolation (침투)</h2>\n<p>N * N의 격자에는 open, block 상태가 있으며 p의 확률로 열리고 1-p의 확률로 막힌다<br>\n격자의 상단과 하단이 연결되어 열려있으면 percolated된 것으로 판단한다</p>\n<ul>\n<li>A group이 B group과 의사 교환을 할 수 있는지</li>\n</ul>\n<p>침투 여부의 값 n보다 작으면 침투하지 못함\n역치값은 시뮬레이션이 필요한데 union-find로만 가능하다</p>\n<h3>Monte carlo simulation</h3>\n<p>기본은 모두 닫혀있으며 랜덤으로 오픈된다.<br>\n0 ~ N<sup>2-1</sup>의 노드를 생성하고 최상단, 최하단에 가상의 노드를 추가한다. <em>추가 노드없이 탐색하는 경우 N<sup>2</sup>의 탐색 시간이 소요된다</em>  </p>","frontmatter":{"title":"알고리즘 week 1"},"excerpt":"UNION-FIND 최소 선형트리 알고리즘의 서브 루틴 Function Description UF(int N) union-find data (0 ~ N-1) union(p, q) add connection p, q connected(p, q…"}},"pageContext":{"slug":"/algorithm/"}},"staticQueryHashes":["63159454"]}