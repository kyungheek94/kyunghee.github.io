{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm-week1/","result":{"data":{"markdownRemark":{"html":"<h1>UNION-FIND</h1>\n<p>최소 선형트리 알고리즘의 서브 루틴</p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UF(int N)</td>\n<td>union-find data (0 ~ N-1)</td>\n</tr>\n<tr>\n<td>union(p, q)</td>\n<td>add connection p, q</td>\n</tr>\n<tr>\n<td>connected(p, q)</td>\n<td>IsUnioned?</td>\n</tr>\n</tbody>\n</table>\n<h2>Quick Find (Eager approach)</h2>\n<ol>\n<li>Initialize<br>\n<code class=\"language-jstext\">id[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code><br>\nindex == value<br>\n<code class=\"language-jstext\">ary[N]</code>으로 N번의 init  </li>\n<li>Find<br>\n<code class=\"language-jstext\">return id[p] == id[q]</code><br>\n노드가 연결됐는지 찾는데 1번의 조회로 해결</li>\n<li>\n<p>Union<br>\n<code class=\"language-jstext\">id[] = [0, 1, 2, 3, 4]</code> - <code class=\"language-jstext\">union(1, 2)</code> -> <code class=\"language-jstext\">id[] = [0, 1, 1, 3, 4]</code><br>\n<code class=\"language-jstext\">p</code>, <code class=\"language-jstext\">q</code> 중 무엇으로 바꿀지 내부적으로 결정해야함<br>\n해당 <code class=\"language-jstext\">parameter</code>의 <code class=\"language-jstext\">index</code>를 찾아 다른 인수의 값으로 수정<br>\nN<sup>2</sup>의 시간이 필요</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-jsjs\"><code class=\"language-jsjs\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>id<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> id<span class=\"token punctuation\">[</span>q<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pid</code></pre></div>\n</li>\n</ol>\n<p> </p>\n<h2>Quick union (Lazy approach)</h2>\n<p>Quick find의 대안. <code class=\"language-jstext\">tree 구조</code>로 구성된 <code class=\"language-jstext\">forest</code></p>\n<ol>\n<li>Initialize<br>\n<code class=\"language-jstext\">id[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></li>\n<li>\n<p>Find<br>\n<code class=\"language-jstext\">Root</code> of <code class=\"language-jstext\">i</code> : <code class=\"language-jstext\">id[id[id[...id[i]...]]]</code><br>\n<code class=\"language-jstext\">id[i]</code>는 <code class=\"language-jstext\">i</code>의 <code class=\"language-jstext\">parent</code>. <code class=\"language-jstext\">parent</code>의 마지막 <code class=\"language-jstext\">parent</code>가 <code class=\"language-jstext\">root</code>  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-jsjs\"><code class=\"language-jsjs\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  i <span class=\"token operator\">=</span> id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-jstext\">Long skinny tree</code>가 될수록 비용이 커짐</p>\n</li>\n<li>Union<br>\n<code class=\"language-jstext\">id[] = [0, 1, 9, 4, 9, 6, 6, 7, 8, 9]</code> -> <code class=\"language-jstext\">union(3, 5)</code><br>\n<code class=\"language-jstext\">p</code>의 <code class=\"language-jstext\">root</code> = <code class=\"language-jstext\">id[3] = id[4] = id[9] = 9</code><br>\n<code class=\"language-jstext\">q</code>의 <code class=\"language-jstext\">root</code> = <code class=\"language-jstext\">id[5] = id[6] = 6</code><br>\n=> <code class=\"language-jstext\">p</code>의 <code class=\"language-jstext\">root</code>인 <code class=\"language-jstext\">id[9]</code>의 값을 <code class=\"language-jstext\">6</code>으로 바꿔준다<br>\n최대 <code class=\"language-jstext\">N</code>번의 접근</li>\n</ol>\n<p> </p>\n<h2>향상된 quick union</h2>\n<p>동적 연결성(Dynamic connectivity) 문제를 해결하기 위함</p>\n<h3>가중치 (weighting)</h3>\n<p><code class=\"language-jstext\">union</code> 시 큰 트리를 작은 트리 아래에 넣지않음<br>\n<code class=\"language-jstext\">tree</code>의 <code class=\"language-jstext\">size</code>를 계속 트래킹 (<code class=\"language-jstext\">weighting</code>을 위한 추가 <code class=\"language-jstext\">ary</code> 사용)</p>\n<p><code class=\"language-jstext\">id[] = [0, 9, 6, 5, 4, 2, 6, 1, 0, 5]</code> -> <code class=\"language-jstext\">union(3, 8)</code><br>\n<code class=\"language-jstext\">id[3] = id[5] = id[2] = id[6]</code>, <code class=\"language-jstext\">id[8] = id[0]</code><br>\n이 때 <code class=\"language-jstext\">8</code>의 <code class=\"language-jstext\">tree</code>가 작기 때문에 <code class=\"language-jstext\">3</code>의 <code class=\"language-jstext\">root</code>를 따름\n=> 평균 거리가 짧아짐</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-jsjs\"><code class=\"language-jsjs\">  i <span class=\"token operator\">=</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n  j <span class=\"token operator\">=</span> <span class=\"token function\">root</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sz<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> sz<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    id<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span> sz<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> sz<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">else</span>\n    id<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> sz<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> sz<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span></code></pre></div>\n<p>node x의 최대 깊이가 클수록 트리는 최소 2배의 노드를 가짐</p>\n<ul>\n<li>x가 속한 tree 크기가 최대 log<sub>2</sub>N배만큼 커짐</li>\n<li>1 ~ log<sub>2</sub>N번 = 2배 = N\nunion = log<sub>2</sub>N</li>\n<li>N이 100만 ~ 10억일 때 20~30의 비용</li>\n</ul>\n<h3>경로 압축 (path compress)</h3>\n<p>node p의 <code class=\"language-jstext\">root</code>를 찾으려면 모든 단계의 노드를 찾아야 함<br>\n=> 모든 경로의 노드가 <code class=\"language-jstext\">root</code>를 가리키게 만듬 (flatten tree)<br>\n간단히 <code class=\"language-jstext\">root</code>를 찾을 때 <code class=\"language-jstext\">id[i] = id[id[i]]</code>로 grand parent를 찾을 수 있음</p>\n<h3>가중치와 경로 압축을 합친 QU</h3>\n<p>node n을 M번 union, find해도 c(N+M log<sup>*</sup> N) 시간 소요  </p>\n<ul>\n<li><em>log<sup>*</sup> N : N을 1로 바꾸기 위해 logN을 취해야하는 횟수</em></li>\n</ul>\n<p> </p>\n<h2>Percolation (침투)</h2>\n<p>N * N의 격자에는 <code class=\"language-jstext\">open</code>, <code class=\"language-jstext\">block</code> 상태가 있으며 <code class=\"language-jstext\">p</code>의 확률로 열리고 <code class=\"language-jstext\">1-p</code>의 확률로 닫힌다<br>\n격자의 상단에서 하단까지 open된 셀들이 연결되면 percolated된 것이다.</p>\n<blockquote>\n<h3>Monte carlo simulation</h3>\n<p>기본은 모두 닫혀있으며 랜덤으로 오픈된다.<br>\n0 ~ N<sup>2-1</sup>의 노드를 생성하고 최상단, 최하단에 가상의 노드를 추가한다. <em>추가 노드없이 탐색하는 경우 N<sup>2</sup>의 탐색 시간이 소요된다</em></p>\n</blockquote>\n<section class=\"tabs-container\">\n  <input class=\"tab\" name=\"social-tab\" id=\"eng-tab\" type=\"radio\" />\n  <blockquote class=\"tab-content\">\n    <h3>Social network connectivity</h3>\n    Assume that the log file is sorted by timestamp and that friendship is an equivalence relation. The running time of your algorithm should be `m log n` or better and use extra space proportional to `n`<br/>\n    Given a social network containing `n` members and a log file containing `m` timestamps at which times pairs of members formed friendships, design an algorithm to determine the earliest time at which all members are connected (i.e., every member is a friend of a friend of a friend ... of a friend).<br/>\n    Assume that the log file is sorted by timestamp and that friendship is an equivalence relation. The running time of your algorithm should be `m log n` or better and use extra space proportional to `n`.\n  </blockquote>\n  <input class=\"tab\" name=\"social-tab\" id=\"kor-tab\" type=\"radio\" checked />\n  <blockquote class=\"tab-content\">\n    <h3>`n`명의 멤버를 가진 소셜 네트워크</h3>\n    한 쌍의 멤버들이 우정을 만든 시간에 대한 `m`개의 타임스탬프들이 포함된 로그파일이 있다.<br/>\n    가장 짧은 시간 안에 모든 멤버들이 연결되는 알고리즘을 설계해라. (예를 들어 모든 맴버들이 친구의 친구의 친구인 경우)<br/>\n    로그 파일이 타임스탬프 기준으로 정렬되어있고 우정은 동등한 값으로 가정한다.<br/>\n    알고리즘의 실행 시간은 `m log n` 이상이고 `n`에 비례하는\u001d 추가 공간을 사용해야한다.<br/>\n  </blockquote>\n  <div class=\"tabs-label\">\n    <label for=\"eng-tab\">Eng</label>\n    <label for=\"kor-tab\">Kor</label>\n  </div>\n</section>\n<section class=\"tabs-container\">\n  <input class=\"tab\" name=\"tab\" id=\"eng-tab2\" type=\"radio\" />\n  <blockquote class=\"tab-content\">\n    Union-find with specific canonical element.<br/>\n    Add a method `find()` to the union-find data type so that `find(i)` returns the largest element in the connected component containing `i`. The operations, `union()`, `connected()`, and `find()` should all take logarithmic time or better.<br/>\n    For example, if one of the connected components is `{1,2,6,9}`, then the `find()` method should return `9` for each of the four elements in the connected components.\n  </blockquote>\n  <input class=\"tab\" name=\"tab\" id=\"kor-tab2\" type=\"radio\" checked />\n  <blockquote class=\"tab-content\">\n    특정한 표준 element와 Union-find가 있다.<br/>\n    UF에 `find()`를 추가하고, `find(i)`는 `i`를 포함하는 연결된 component 중 가장 큰 element를 리턴한다. 해당 연산은 `union()`, `connected()`, `find()`들은 모두 로그 시간 이상이 소요된다.<br/>\n    예시로 연결된 `{1,2,6,9}` component가 있다. `find()`는 연결된 component의 모든 요소 각각에 9를 리턴해야 한다.\n  </blockquote>\n  <div class=\"tabs-label\">\n    <label for=\"eng-tab2\">Eng</label>\n    <label for=\"kor-tab2\">Kor</label>\n  </div>\n</section>\n<section class=\"tabs-container\">\n  <input class=\"tab\" name=\"s-tab\" id=\"eng-tab3\" type=\"radio\" />\n  <blockquote class=\"tab-content\">\n  <h3>Successor with delete.</h3>\n  Given a set of `n` integers `S={0,1,...,n−1}` and a sequence of requests of the following form:<br/>\n  - Remove `x` from `S`<br/>\n  - Find the successor of `x`: the smallest `y` in `S` such that `y ≥ x`<br/>\n  design a data type so that all operations (except construction) take logarithmic time or better in the worst case.\n  </blockquote>\n  <input class=\"tab\" name=\"s-tab\" id=\"kor-tab3\" type=\"radio\" checked />\n  <blockquote class=\"tab-content\">\n    <h3>삭제와 후처리</h3>\n    `S={0,1,...,n−1}`로 만들어진 n개의 int가 있고 하단의 처리 순서를 따른다.<br/>\n    - `S`에서 `x`를 삭제한다<br/>\n    - `x`의 후처리 : `S`에서 y ≥ x와 같은 가장 작은 `y`를 찾는다.<br/>\n    모든 연산이 최악의 경우 로그 시간 이상을 사용하도록 데이터 유형을 설계한다.\n  </blockquote>\n  <div class=\"tabs-label\">\n    <label for=\"eng-tab3\">Eng</label>\n    <label for=\"kor-tab3\">Kor</label>\n  </div>\n</section>","frontmatter":{"title":"알고리즘 week 1","date":"September 20, 2020"},"excerpt":"UNION-FIND 최소 선형트리 알고리즘의 서브 루틴 Function Description UF(int N) union-find data (0 ~ N-1) union(p, q) add connection p, q connected(p, q…"}},"pageContext":{"slug":"/algorithm-week1/"}},"staticQueryHashes":["63159454"]}